#!/usr/bin/env python3
"""
–ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è main.py —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π –∞–Ω–∞–ª–∏–∑–∞ –∑–≤–æ–Ω–∫–æ–≤
"""
import os
import requests
import openai
import asyncio
import json
from telegram import Bot
from dotenv import load_dotenv
from datetime import datetime, timedelta
import pytz
from prompt_loader import prompt_loader

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ main.py
from main import (
    load_processed_calls, save_processed_call, authenticate_telfin, 
    get_recent_calls, download_recording, transcribe_with_yandex, 
    transcribe_with_openai, send_telegram_report, has_recording, 
    get_call_cdr, MOSCOW_TZ
)

def analyze_with_gpt_new(transcript, call_info=None):
    """
    NEW: Analyze call transcript with JSON-based logic focused on critical manager errors.
    
    Args:
        transcript (str): Transcribed text from the call
        call_info (dict): Optional call metadata (duration, time, etc.)
    
    Returns:
        dict: JSON response with analysis or {"status": "ignore"}
    """
    openai_api_key = os.environ.get("OPENAI_API_KEY") or os.getenv("OPENAI_API_KEY")
    
    if not openai_api_key or openai_api_key == "your_openai_api_key":
        print("Error: OPENAI_API_KEY not configured")
        return {"status": "ignore", "error": "no_api_key"}
        
    if not transcript:
        print("Error: No transcript provided for analysis")
        return {"status": "ignore", "error": "no_transcript"}
    
    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–µ –≤–Ω–µ—à–Ω–∏–µ –ø—Ä–æ–º–ø—Ç—ã
        print("üìù Loading prompts for critical error detection...")
        full_prompt = prompt_loader.get_full_analysis_prompt(transcript, call_info)
        
        print("ü§ñ Sending to GPT-4 for critical error analysis...")
        client = openai.OpenAI(api_key=openai_api_key)
        
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "user", "content": full_prompt}
            ],
            max_tokens=800,   # –£–º–µ–Ω—å—à–∏–ª–∏ - –Ω—É–∂–µ–Ω —Ç–æ–ª—å–∫–æ JSON
            temperature=0.1   # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ JSON
        )
        
        raw_response = response.choices[0].message.content.strip()
        print(f"‚úÖ GPT-4 response received: {len(raw_response)} characters")
        
        # –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
        try:
            # –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ markdown –æ–±—ë—Ä—Ç–∫–∏
            if raw_response.startswith('```json'):
                raw_response = raw_response[7:-3].strip()
            elif raw_response.startswith('```'):
                raw_response = raw_response[3:-3].strip()
                
            analysis_json = json.loads(raw_response)
            print(f"‚úÖ JSON parsed successfully: status = {analysis_json.get('status', 'unknown')}")
            return analysis_json
            
        except json.JSONDecodeError as e:
            print(f"‚ö†Ô∏è JSON parse error: {e}")
            print(f"‚ö†Ô∏è Raw response: {raw_response[:200]}...")
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞ - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
            return {"status": "ignore", "error": "json_parse_failed"}
        
    except Exception as e:
        print(f"‚ùå Error during GPT-4 analysis: {e}")
        return {"status": "ignore", "error": str(e)}

def main_new():
    """
    NEW: Main function with updated logic - only alerts on critical manager errors
    """
    print("=== NEW: Critical Error Detection System for 29ROZ ===")
    print("üéØ Focus: ONLY manager errors that cost sales")
    
    hostname = os.environ.get("TELFIN_HOSTNAME") or os.getenv("TELFIN_HOSTNAME")
    login = os.environ.get("TELFIN_LOGIN") or os.getenv("TELFIN_LOGIN")
    password = os.environ.get("TELFIN_PASSWORD") or os.getenv("TELFIN_PASSWORD")
    yandex_api_key = os.environ.get("YANDEX_API_KEY") or os.getenv("YANDEX_API_KEY")
    
    if not hostname or not login or not password:
        print("Error: TELFIN_HOSTNAME, TELFIN_LOGIN and TELFIN_PASSWORD must be set")
        return
    
    if not yandex_api_key:
        print("Error: YANDEX_API_KEY must be set")
        return
    
    print(f"\n1. Authenticating with Telphin API at {hostname}...")
    token = authenticate_telfin(hostname, login, password)
    
    if not token:
        print("Authentication failed. Cannot proceed.")
        return
    
    print("\n2. Loading processed calls history...")
    processed_calls = load_processed_calls()
    print(f"Found {len(processed_calls)} previously processed calls")
    
    print("\n3. Retrieving recent calls...")
    calls = get_recent_calls(hostname, token)
    
    if calls is None:
        print("Failed to retrieve calls.")
        return
    
    new_calls = [call for call in calls if call.get('call_uuid') not in processed_calls]
    
    print(f"Found {len(calls)} total calls, {len(new_calls)} new calls to process")
    
    if not new_calls:
        print("‚úÖ No new calls to process.")
        return
    
    processed_count = 0
    critical_alerts = 0
    
    print("\n4. Filtering for incoming calls with recordings...")
    incoming_calls_with_recordings = []
    
    for call in new_calls:
        flow = call.get('flow', '')
        call_uuid = call.get('call_uuid')
        
        if flow != 'in':
            print(f"Skipping call {call_uuid}: flow={flow} (not incoming)")
            continue
            
        if not call_uuid:
            print(f"Skipping call: missing call_uuid")
            continue
            
        has_rec, rec_size = has_recording(hostname, token, call_uuid)
        
        if has_rec:
            incoming_calls_with_recordings.append(call)
            print(f"‚úÖ Found incoming call with recording: {call_uuid} ({rec_size} bytes)")
        else:
            print(f"Skipping call {call_uuid}: no recording available")
    
    print(f"Filtered to {len(incoming_calls_with_recordings)} incoming calls with recordings")
    
    if not incoming_calls_with_recordings:
        print("‚úÖ No incoming calls with recordings to process.")
        return
    
    for i, call in enumerate(incoming_calls_with_recordings):
        call_uuid = call.get('call_uuid')
        
        # üîí EARLY SAVE: Mark call as being processed
        print(f"üîí Marking call {call_uuid} as processing...")
        save_processed_call(call_uuid, "processing")
            
        call_time_str = call.get('start_time_gmt', 'N/A')
        try:
            call_time_utc = datetime.strptime(call_time_str, "%Y-%m-%d %H:%M:%S")
            call_time_moscow = call_time_utc.replace(tzinfo=pytz.UTC).astimezone(MOSCOW_TZ)
            moscow_time_str = call_time_moscow.strftime("%Y-%m-%d %H:%M:%S MSK")
        except (ValueError, TypeError):
            moscow_time_str = call_time_str
        
        print(f"\nProcessing call {i+1}/{len(incoming_calls_with_recordings)}: {call_uuid}")
        print(f"  Details: {moscow_time_str} | {call.get('duration')}s | {call.get('flow')} | {call.get('result')}")
        
        audio_data = download_recording(hostname, token, call_uuid)
        
        if audio_data:
            processed_count += 1
            print(f"‚úÖ Recording found! Processing...")
            
            # Transcribe with Yandex SpeechKit first, fallback to OpenAI
            transcribed_text = transcribe_with_yandex(yandex_api_key, audio_data)
            
            if transcribed_text == "–ê—É–¥–∏–æ–∑–∞–ø–∏—Å—å —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏ (–±–æ–ª–µ–µ 30 —Å–µ–∫—É–Ω–¥)":
                print("Yandex limit exceeded, trying OpenAI Whisper...")
                openai_api_key = os.environ.get("OPENAI_API_KEY")
                if openai_api_key:
                    transcribed_text = transcribe_with_openai(openai_api_key, audio_data)
                    if transcribed_text:
                        print("‚úÖ OpenAI Whisper transcription completed")
                    else:
                        print("‚ùå OpenAI Whisper transcription failed")
                else:
                    print("‚ùå OPENAI_API_KEY not configured")
            
            if transcribed_text:
                print(f"‚úÖ Transcription completed")
                
                # –ü–µ—Ä–µ–¥–∞—ë–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–≤–æ–Ω–∫–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
                call_info_for_analysis = {
                    'duration': call.get('duration', 0),
                    'time': call.get('start_time_gmt', ''),
                    'direction': call.get('flow', 'unknown')
                }
                
                analysis_result = analyze_with_gpt_new(transcribed_text, call_info_for_analysis)
                
                if analysis_result and isinstance(analysis_result, dict):
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –∞–Ω–∞–ª–∏–∑–∞
                    if analysis_result.get('status') == 'alert':
                        print(f"üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –ú–ï–ù–ï–î–ñ–ï–†–ê –û–ë–ù–ê–†–£–ñ–ï–ù–ê!")
                        print(f"‚öôÔ∏è –ö–æ–¥: {analysis_result.get('error_code', 'UNKNOWN')}")
                        print(f"üìã –û–ø–∏—Å–∞–Ω–∏–µ: {analysis_result.get('error_description', 'N/A')}")
                        
                        # –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–æ–º–µ—Ä –∫–ª–∏–µ–Ω—Ç–∞
                        def clean_phone_number(number):
                            if number and number != 'N/A':
                                return number.split('@')[0]
                            return 'N/A'
                        
                        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–º–µ—Ä –∫–ª–∏–µ–Ω—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞
                        if call.get('flow') == 'in':  # –í—Ö–æ–¥—è—â–∏–π - –∫–ª–∏–µ–Ω—Ç –∑–≤–æ–Ω–∏—Ç –Ω–∞–º
                            client_phone = clean_phone_number(call.get('bridged_username') or call.get('from_username'))
                        else:  # –ò—Å—Ö–æ–¥—è—â–∏–π - –º—ã –∑–≤–æ–Ω–∏–º –∫–ª–∏–µ–Ω—Ç—É
                            client_phone = clean_phone_number(call.get('to_username') or call.get('bridged_username'))
                        
                        # –°–æ–∑–¥–∞—ë–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –æ—Ç—á—ë—Ç
                        alert_template = prompt_loader.get_alert_template()
                        critical_report = alert_template.format(
                            error_code=analysis_result.get('error_code', 'UNKNOWN'),
                            error_description=analysis_result.get('error_description', 'N/A'),
                            client_phone=client_phone,
                            context=analysis_result.get('context', 'N/A'),
                            solution=analysis_result.get('solution', 'N/A')
                        )
                        
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –æ—Ç—á—ë—Ç
                        telegram_success = asyncio.run(send_telegram_report(critical_report))
                        
                        if telegram_success:
                            critical_alerts += 1
                            save_processed_call(call_uuid, "critical_alert_sent")
                            print("üö® –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –æ—Ç—á—ë—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ Telegram!")
                        else:
                            print("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ—Ç—á—ë—Ç–∞")
                            save_processed_call(call_uuid, "alert_failed")
                            
                    elif analysis_result.get('status') == 'ignore':
                        print(f"‚úÖ –ó–≤–æ–Ω–æ–∫ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω: –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –≤–º–µ—à–∞—Ç–µ–ª—å—Å—Ç–≤–∞")
                        save_processed_call(call_uuid, "analyzed_ignore")
                    else:
                        print(f"‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª–∏–∑–∞: {analysis_result}")
                        save_processed_call(call_uuid, "analysis_unexpected")
                else:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∑–≤–æ–Ω–∫–∞")
                    save_processed_call(call_uuid, "analysis_failed")
            else:
                print("‚ùå Transcription failed")
                save_processed_call(call_uuid, "transcription_error")
        else:
            print(f"‚ùå No recording available")
            save_processed_call(call_uuid, "no_recording")
    
    print(f"\n=== NEW ANALYSIS COMPLETE ===")
    print(f"Total calls retrieved: {len(calls)}")
    print(f"New calls found: {len(new_calls)}")
    print(f"Incoming calls with recordings: {len(incoming_calls_with_recordings)}")
    print(f"Calls processed: {processed_count}")
    print(f"üö® CRITICAL ALERTS SENT: {critical_alerts}")
    print("üéØ System focused on critical manager errors only")

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1 and sys.argv[1] == "scheduler":
        main_new()
    elif os.environ.get("PORT"):
        # Keep web handler from original main.py
        from main import web_handler
        web_handler()
    else:
        main_new()